import argparse
import os
import numpy as np
import pandas as pd
from sklearn import metrics
from sklearn.feature_selection import RFECV
from sklearn.model_selection import GridSearchCV, train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn_porter import Porter

def model(parameters, X, y, score_function):
    clf_cv = GridSearchCV(DecisionTreeClassifier(), parameters).fit(X, y)
    clf = DecisionTreeClassifier(min_samples_leaf=clf_cv.best_params_['min_samples_leaf'],
                                 min_samples_split=clf_cv.best_params_['min_samples_split'],
                                 criterion=clf_cv.best_params_['criterion'],
                                 splitter='best')
    selector = RFECV(clf, step=1, cv=10, scoring=metrics.make_scorer(score_function))
    selector = selector.fit(X, y)
    return selector

def export_model_to_js(selector, filename):
    porter = Porter(selector.estimator_, language='js')
    output = porter.export(embed_data=True)
    with open(os.path.join(args.out_dir, filename), mode='w+', encoding='utf8') as f:
        f.write('export ' + output)


parser = argparse.ArgumentParser(description='Train a decision tree to recognize headings and their levels.')
parser.add_argument('dataset_dir', help='folder containing the .csv files generated by build_dataset.py')
parser.add_argument('out_dir', help='folder in which to save the two trained models')
args = parser.parse_args()

dataset_dir = args.dataset_dir
paths = os.listdir(dataset_dir)
X_heading = []
y_heading = []
X_lvl = []
y_lvl = []

for path in paths:
    df = pd.read_csv(os.path.join(dataset_dir, path), header=0)
    df_lvl = df.loc[df['label']=='heading'].reset_index().copy()
    df_lvl['font_size'] = df_lvl['font_size'].apply(lambda x: round(x, 2))
    df['label'] = df['label'].apply(lambda x: 1 if x == 'heading' else 0)

    for i in range(len(df)):
        X_heading.append([df['is_different_style'][i], df['is_font_bigger'][i],
                          df['is_font_unique'][i], df['text_case'][i],
                          df['word_count'][i], df['different_color'][i],
                          df['is_number'][i]
                          ])
    y_heading = y_heading + list(df['label'])

    for i in range(len(df_lvl)):
        X_lvl.append([df_lvl['font_size'][i], df_lvl['is_bold'][i],
                      df_lvl['text_case'][i], df_lvl['is_font_bigger'][i],
                      df_lvl['different_color'][i]
                      ])    
    y_lvl = y_lvl + list(df_lvl['level'])

X_train1, X_test1, y_train1, y_test1 = train_test_split(X_heading, y_heading, test_size=0.2)
X_train2, X_test2, y_train2, y_test2 = train_test_split(X_lvl, y_lvl, test_size=0.2)

parameters_heading = {'min_samples_leaf':[1,2,3,4,5,6,7], 'min_samples_split':[2,3,4,5,6,7], 'criterion':['entropy','gini']}
parameters_lvl = {'min_samples_leaf':[1,2,3,4,5], 'min_samples_split':[2,3,4,5], 'criterion':['entropy','gini']}              

selector_heading = model(parameters_heading, X_train1, y_train1, metrics.f1_score)
selector_lvl = model(parameters_lvl, X_train2, y_train2, metrics.accuracy_score)

y_pred_heading = selector_heading.predict(X_test1)
y_pred_lvl = selector_lvl.predict(X_test2)

print('precision (heading detection):', metrics.precision_score(y_test1, y_pred_heading))
print('recall (heading detection):', metrics.recall_score(y_test1, y_pred_heading))
print('f1 (heading detection):', metrics.f1_score(y_test1, y_pred_heading))

print('accuracy (headings level):', metrics.accuracy_score(y_test2, y_pred_lvl))

export_model_to_js(selector_heading, 'model.js')
export_model_to_js(selector_lvl, 'model_level.js')
